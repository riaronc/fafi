import { z } from 'zod';
import { TransactionType } from '@prisma/client'; // Assuming TransactionType enum is generated by Prisma

// Base schema for common transaction fields
const transactionBaseSchema = z.object({
  // Amount is received in major units (e.g., dollars)
  amount: z.number({ required_error: 'Amount is required' }).positive('Amount must be positive'),
  description: z.string().max(255).optional().nullable(),
  date: z.coerce.date({ required_error: 'Date is required' }), // Coerce string/number to Date
  categoryId: z.string({ required_error: 'Category is required' }).uuid(), 
  accountId: z.string({ required_error: 'Account is required' }).uuid(), // For Expense/Income, this is the primary account
});

// Schema specifically for creating an INCOME transaction
export const createIncomeSchema = transactionBaseSchema;

// Schema specifically for creating an EXPENSE transaction
export const createExpenseSchema = transactionBaseSchema;

// Schema specifically for creating a TRANSFER transaction (base structure)
const transferBase = z.object({ 
  type: z.literal(TransactionType.TRANSFER),
  amount: z.number({ required_error: 'Amount is required' }).positive('Amount must be positive'),
  description: z.string().max(255).optional().nullable(),
  date: z.coerce.date({ required_error: 'Date is required' }),
  sourceAccountId: z.string({ required_error: 'Source account is required' }).uuid(),
  destinationAccountId: z.string({ required_error: 'Destination account is required' }).uuid(),
});

// General schema for creating any transaction (used in form, dispatched to specific actions later)
// We add the 'type' field here for the form to decide which fields are needed
export const createTransactionSchema = z.discriminatedUnion("type", [
  // Income
  transactionBaseSchema.extend({ type: z.literal(TransactionType.INCOME) }),
  // Expense
  transactionBaseSchema.extend({ type: z.literal(TransactionType.EXPENSE) }),
  // Transfer (using the base structure - refinement will happen in server action)
  transferBase 
]);

// Schema for updating a transaction (less strict, allows partial updates)
// Note: Handling updates, especially changing type or accounts, can be complex.
// This is a simplified version assuming you mostly update details like description, date, category, amount.
// Updating accounts/type might require deleting and recreating or more complex logic.
export const updateTransactionSchema = z.object({
  amount: z.number().positive('Amount must be positive').optional(),
  description: z.string().max(255).optional().nullable(),
  date: z.coerce.date().optional(), 
  categoryId: z.string().uuid().optional(),
  // For simplicity, updating accounts involved in the transaction might be disallowed
  // or handled via specific actions if necessary.
});


// Derived types
export type CreateTransactionInput = z.infer<typeof createTransactionSchema>;
export type UpdateTransactionInput = z.infer<typeof updateTransactionSchema>; 